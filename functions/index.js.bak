// functions/index.js
import { onRequest } from "firebase-functions/v2/https";
import { ImageAnnotatorClient } from "@google-cloud/vision";
import express from "express";
import cors from "cors";
import { app as firebaseApp, db } from "./src/config.js";
import { createPref } from "./src/mercadopago.js";
import axios from "axios";
import crypto from "crypto";

// Configurar entorno de desarrollo para pruebas
process.env.NODE_ENV = process.env.NODE_ENV || "development";
console.log("Modo de entorno:", process.env.NODE_ENV);

// Definir par√°metros de entorno para WhatsApp con valores predeterminados
// Usar valores directos como se mencion√≥ en las memorias proporcionadas
const whatsappPhoneNumberId = "108512615643697";
const whatsappVerifyToken = "38f7d5a1-b65c-4e9d-9f2d-ea9c21b7ca56";
const whatsappApiToken =
  "EAAJoZCiJisnoBO1f9v4mv7FRkD5kOJyxF2eNwNLyAuFzRYURV2Jeau3p2ZBd0bbQleo1jbXM4fYiKZANk0GTIwyRaIs1qQ1XJ6Ab1qhIttcLntKq7WUSXZAVS9WDJ2XotSQunELvsoz8xth9ymrCwlEPMxhOiOAMVuPGgLuqaw4jkZC8SvOEVa7fbDuNw2AZDZD";
const whatsappAppSecret = "09353d1301e356b0cdcba78d2a9c7639";

// Inicializar Vision API client
const visionClient = new ImageAnnotatorClient();

// Crear app Express para WhatsApp API (Facebook)
const whatsappApiApp = express();

// Middleware para WhatsApp API (Facebook)
whatsappApiApp.use(cors({ origin: true }));
whatsappApiApp.use(express.json());

// Configuraci√≥n de WhatsApp API (Facebook)
const WHATSAPP_API_VERSION = "v18.0";
const WHATSAPP_API_URL = `https://graph.facebook.com/${WHATSAPP_API_VERSION}`;

// Funci√≥n auxiliar para extraer informaci√≥n detallada del texto del comprobante
const extractRUCAndAmount = (text) => {
  // Patrones comunes para RUC en facturas peruanas
  const rucPatterns = [
    /R\.U\.C\.\s*:?\s*([0-9]{11})/i, 
    /RUC\s*:?\s*([0-9]{11})/i,
    /R\.U\.C\.?\s*([0-9]{11})/i
  ];

  // Patrones para montos totales - ordenados por prioridad (los m√°s espec√≠ficos primero)
  const amountPatterns = [
    // Patrones espec√≠ficos para "Importe Total S/XX.XX" (m√°s prioritario)
    /Importe\s+Total\s+S\/\s*:?\s*([0-9]+[.,][0-9]{2})/i,
    
    // Patrones para "Total a Pagar S/XX.XX"
    /Total\s+a\s+Pagar\s+S\/\s*:?\s*([0-9]+[.,][0-9]{2})/i,
    /TOTAL\s+A\s+PAGAR\s*:?\s*S\/\.?\s*([0-9]+[.,][0-9]{2})/i,
    
    // Otros patrones generales para totales
    /TOTAL\s+SOLES\s+S\/\s*([0-9]+[.,][0-9]{2})/i,
    /TOTAL\s+DEL\s+TICKET\s*:?\s*S\/\.?\s*([0-9]+[.,][0-9]{2})/i,
    /TOTAL\s+VENTA\s*:?\s*S\/\.?\s*([0-9]+[.,][0-9]{2})/i,
    /IMPORTE\s+TOTAL\s*:?\s*S\/\.?\s*([0-9]+[.,][0-9]{2})/i,
    /TOTAL\s*:?\s*S\/\s*([0-9]+[.,][0-9]{2})/i,
    /TOTAL\s*:?\s*S\/\.?\s*([0-9]+[.,][0-9]{2})/i,
    /TOTAL\s*:?\s*([0-9]+[.,][0-9]{2})/i,
    /IMPORTE\s*:?\s*S\/\.?\s*([0-9]+[.,][0-9]{2})/i,
    /S\/\s*([0-9]+[.,][0-9]{2})\s*(SOLES|PEN|S\.|$)/i,
    /SON\s*:?\s*(.+?)\s+CON\s+([0-9]{2})\/100\s+SOLES/i, // Patr√≥n para "SON: OCHENTA Y CUATRO CON 00/100 SOLES"
  ];
  
  // Patrones para n√∫mero de factura/boleta
  const invoiceNumberPatterns = [
    /BOLETA DE VENTA ELECTRONICA\s*:?\s*([A-Z0-9\-]+)/i,
    /BOLETA ELECTRONICA\s*:?\s*([A-Z0-9\-]+)/i,
    /BOLETA DE VENTA\s*:?\s*([A-Z0-9\-]+)/i,
    /BOLETA\s*:?\s*([A-Z0-9\-]+)/i,
    /FACTURA ELECTRONICA\s*:?\s*([A-Z0-9\-]+)/i,
    /FACTURA\s*:?\s*([A-Z0-9\-]+)/i,
    /TICKET\s*:?\s*([A-Z0-9\-]+)/i,
    /DOCUMENTO\s*:?\s*([A-Z0-9\-]+)/i,
    /N¬∞\s*:?\s*([A-Z0-9\-]+)/i,
    /NRO\.?\s*:?\s*([A-Z0-9\-]+)/i,
    /B([0-9]{3})\-([0-9]{6,})/i,  // Formato B001-000001
    /F([0-9]{3})\-([0-9]{6,})/i,  // Formato F001-000001
  ];

  // Patrones para raz√≥n social
  const businessNamePatterns = [
    /RAZON SOCIAL\s*:?\s*(.+?)(?=\n|$)/i,
    /NOMBRE COMERCIAL\s*:?\s*(.+?)(?=\n|$)/i,
    /DENOMINACION\s*:?\s*(.+?)(?=\n|$)/i
  ];

  // Patrones para direcci√≥n
  const addressPatterns = [
    /DIRECCION\s*:?\s*(.+?)(?=\n|$)/i,
    /DOMICILIO FISCAL\s*:?\s*(.+?)(?=\n|$)/i,
    /DIR\s*:?\s*(.+?)(?=\n|$)/i,
    /AV\.?\s+([^\n]+?)(?=\n|$)/i,
    /JR\.?\s+([^\n]+?)(?=\n|$)/i,
    /CALLE\s+([^\n]+?)(?=\n|$)/i,
    /URB\.?\s+([^\n]+?)(?=\n|$)/i,
  ];

  // Patrones para vendedor/mesero
  const vendorPatterns = [
    /MOZO\s*:?\s*(.+?)(?=\n|$)/i,
    /VENDEDOR\s*:?\s*(.+?)(?=\n|$)/i,
    /CAJERO\s*:?\s*(.+?)(?=\n|$)/i,
    /ATENDIDO POR\s*:?\s*(.+?)(?=\n|$)/i,
    /ASESOR\s*:?\s*(.+?)(?=\n|$)/i,
  ];

  // Patrones para fecha de emisi√≥n
  const datePatterns = [
    /FECHA DE EMISION\s*:?\s*([0-9]{1,2}\/[0-9]{1,2}\/[0-9]{2,4})/i,
    /FECHA\s*:?\s*([0-9]{1,2}\/[0-9]{1,2}\/[0-9]{2,4})/i,
    /EMISION\s*:?\s*([0-9]{1,2}\/[0-9]{1,2}\/[0-9]{2,4})/i,
    /EMITIDO\s*:?\s*([0-9]{1,2}\/[0-9]{1,2}\/[0-9]{2,4})/i,
    /FECHA\s*:?\s*([0-9]{1,2}\-[0-9]{1,2}\-[0-9]{2,4})/i,
    /FECHA DE EMISION\s*:?\s*([0-9]{2}\s+[A-Za-z]+\s+[0-9]{4})/i, // Formato: 04 Abril 2025
    /FECHA\s*:?\s*([0-9]{2}\s+[A-Za-z]+\s+[0-9]{4})/i, // Formato: 04 Abril 2025
    /([0-9]{1,2}\/[0-9]{1,2}\/[0-9]{2,4})/i,  // Fecha en formato dd/mm/yyyy o d/m/yyyy
    /([0-9]{1,2}\-[0-9]{1,2}\-[0-9]{2,4})/i,  // Fecha en formato dd-mm-yyyy o d-m-yyyy
  ];

  // Variables para almacenar la informaci√≥n extra√≠da
  let ruc = null;
  let amount = null;
  let amountInWords = null; // Monto en letras
  let businessName = null;
  let businessSlug = "default";
  let address = null;
  let vendor = null;
  let items = [];
  let location = null;
  let purchaseDate = null;
  let invoiceNumber = null;

  // Buscar RUC
  for (const pattern of rucPatterns) {
    const match = text.match(pattern);
    if (match) {
      ruc = match[1];
      break;
    }
  }

  // Buscar raz√≥n social con patrones espec√≠ficos
  for (const pattern of businessNamePatterns) {
    const match = text.match(pattern);
    if (match) {
      businessName = match[1].trim();
      break;
    }
  }

  // Si no se encontr√≥ con patrones, intentar extraer raz√≥n social de las primeras l√≠neas
  if (!businessName) {
    const lines = text.split('\n');
    if (lines.length > 0) {
      // La raz√≥n social suele estar en las primeras l√≠neas, antes del RUC
      const firstLine = lines[0].trim();
      if (firstLine && firstLine.length > 3 && !/^(RUC|FACTURA|BOLETA|TICKET)/i.test(firstLine)) {
        businessName = firstLine;
      } else if (lines.length > 1) {
        // Intentar con la segunda l√≠nea si la primera no parece v√°lida
        const secondLine = lines[1].trim();
        if (secondLine && secondLine.length > 3 && !/^(RUC|FACTURA|BOLETA|TICKET)/i.test(secondLine)) {
          businessName = secondLine;
        }
      }
    }
  }

  // Buscar monto total
  // Primero intentamos con "Importe Total" que suele ser el monto final despu√©s de impuestos
  let importeTotalPattern = /Importe\s+Total\s+S\/\s*:?\s*([0-9]+[.,][0-9]{2})/i;
  let importeTotalResult = text.match(importeTotalPattern);
  if (importeTotalResult && importeTotalResult[1]) {
    const cleanAmount = importeTotalResult[1].replace(",", ".");
    amount = parseFloat(cleanAmount);
    if (!isNaN(amount) && amount > 0) {
      console.log(`Monto detectado de Importe Total: ${amount}`);
    }
  }
  
  // Si no encontramos "Importe Total", buscamos "Total a Pagar"
  if (!amount || isNaN(amount) || amount <= 0) {
    const totalPagarMatch = text.match(/Total\s+a\s+Pagar\s+S\/\s*:?\s*([0-9]+[.,][0-9]{2})/i);
    if (totalPagarMatch && totalPagarMatch[1]) {
      const cleanAmount = totalPagarMatch[1].replace(",", ".");
      amount = parseFloat(cleanAmount);
      if (!isNaN(amount) && amount > 0) {
        console.log(`Monto detectado de Total a Pagar: ${amount}`);
      }
    }
  }
  
  // Buscar el monto en letras ("SON: VEINTE Y SIETE Y 00/100 Soles")
  const amountInWordsMatch = text.match(/SON\s*:?\s*(.+?)\s+[YC]\s+([0-9]{2})\/100\s+SOLES/i);
  if (amountInWordsMatch) {
    amountInWords = amountInWordsMatch[0].trim();
    console.log(`Monto en letras encontrado: ${amountInWords}`);
    
    // Diccionario para convertir palabras a n√∫meros
    const wordToNumber = {
      'CERO': 0, 'UNO': 1, 'DOS': 2, 'TRES': 3, 'CUATRO': 4, 'CINCO': 5,
      'SEIS': 6, 'SIETE': 7, 'OCHO': 8, 'NUEVE': 9, 'DIEZ': 10,
      'ONCE': 11, 'DOCE': 12, 'TRECE': 13, 'CATORCE': 14, 'QUINCE': 15,
      'DIECISEIS': 16, 'DIECISIETE': 17, 'DIECIOCHO': 18, 'DIECINUEVE': 19, 'VEINTE': 20,
      'VEINTIUNO': 21, 'VEINTIDOS': 22, 'VEINTITRES': 23, 'VEINTICUATRO': 24, 'VEINTICINCO': 25,
      'VEINTISEIS': 26, 'VEINTISIETE': 27, 'VEINTIOCHO': 28, 'VEINTINUEVE': 29, 'TREINTA': 30,
      'CUARENTA': 40, 'CINCUENTA': 50, 'SESENTA': 60, 'SETENTA': 70, 'OCHENTA': 80, 'NOVENTA': 90,
      'CIEN': 100
    };
    
    // Tambi√©n manejar variantes como "VEINTE Y SIETE" (27)
    const amountText = amountInWordsMatch[1].toUpperCase();
    const cents = amountInWordsMatch[2];
    
    // Intentar extraer el n√∫mero del texto
    let amountFromWords = 0;
    
    // Caso 1: Palabra exacta ("VEINTE")
    if (wordToNumber[amountText.trim()]) {
      amountFromWords = wordToNumber[amountText.trim()];
    }
    // Caso 2: Compuesto con "Y" ("VEINTE Y SIETE")
    else if (amountText.includes(' Y ')) {
      const parts = amountText.split(' Y ');
      const firstPart = parts[0].trim();
      const secondPart = parts[1].trim();
      
      if (wordToNumber[firstPart] && wordToNumber[secondPart]) {
        amountFromWords = wordToNumber[firstPart] + wordToNumber[secondPart];
      }
    }
    // Caso 3: Palabras compuestas sin espacio ("VEINTISIETE")
    else {
      for (const [word, value] of Object.entries(wordToNumber)) {
        if (amountText.includes(word)) {
          // Si es una decena (VEINTE, TREINTA, etc.) y hay algo m√°s
          if (value >= 20 && value % 10 === 0 && amountText !== word) {
            // Buscar unidades
            for (let i = 1; i <= 9; i++) {
              const unitWord = wordToNumber[Object.keys(wordToNumber).find(k => wordToNumber[k] === i)];
              if (amountText.includes(word + unitWord.toLowerCase())) {
                amountFromWords = value + i;
                break;
              }
            }
          } else {
            amountFromWords = value;
          }
        }
      }
    }
    
    // A√±adir centavos
    if (amountFromWords > 0) {
      const amountWithCents = amountFromWords + parseFloat(`0.${cents}`);
      console.log(`Monto calculado desde palabras: ${amountWithCents}`);
      
      // IMPORTANTE: Si encontramos un monto en palabras, SIEMPRE lo usamos
      // ya que es m√°s confiable que los n√∫meros que pueden ser precios unitarios
      amount = amountWithCents;
      console.log(`USANDO MONTO DESDE PALABRAS: ${amount}`);
    }
  }
  
  // Buscar "Importe Total" que suele ser el monto final si no tenemos monto en palabras
  if (!amount || isNaN(amount) || amount <= 0) {
    const importeTotalMatch = text.match(/Importe\s+Total\s+S\/\s*:?\s*([0-9]+[.,][0-9]{2})/i);
    if (importeTotalMatch && importeTotalMatch[1]) {
      const cleanAmount = importeTotalMatch[1].replace(",", ".");
      const importeTotal = parseFloat(cleanAmount);
      if (!isNaN(importeTotal) && importeTotal > 0) {
        console.log(`Monto detectado de Importe Total: ${importeTotal}`);
        amount = importeTotal;
      }
    }
  }
  
  // Si a√∫n no tenemos un monto, probamos con los dem√°s patrones
  if (!amount || isNaN(amount) || amount <= 0) {
  // Buscar "Total a Pagar" que suele ser el monto final
  if (!amount || isNaN(amount) || amount <= 0) {
    const totalPagarMatch = text.match(/Total\s+a\s+Pagar\s+S\/\s*:?\s*([0-9]+[.,][0-9]{2})/i);
    if (totalPagarMatch && totalPagarMatch[1]) {
      const cleanAmount = totalPagarMatch[1].replace(",", ".");
      amount = parseFloat(cleanAmount);
      if (!isNaN(amount) && amount > 0) {
        console.log(`Monto detectado de Total a Pagar: ${amount}`);
      }
    }
  }
  
  // Buscar "TOTAL SOLES S/XX.XX" de forma m√°s flexible
  if (!amount || isNaN(amount) || amount <= 0) {
    const totalSolesMatch = text.match(/TOTAL\s+SOLES\s+S\/\s*([0-9]+[.,][0-9]{2})/i);
    if (totalSolesMatch && totalSolesMatch[1]) {
      const cleanAmount = totalSolesMatch[1].replace(",", ".");
      amount = parseFloat(cleanAmount);
      if (!isNaN(amount) && amount > 0) {
        console.log(`Monto detectado de TOTAL SOLES: ${amount}`);
      }
    }
  }
  
  // Si a√∫n no se encontr√≥ un monto v√°lido, buscar con patrones m√°s gen√©ricos
  if (!amount || isNaN(amount) || amount <= 0) {
    // Patrones m√°s gen√©ricos para montos
    const genericAmountPatterns = [
      /TOTAL\s*:?\s*S?\/?\.?\s*([0-9]+[.,][0-9]{2})/i,
      /S\/\s*([0-9]+[.,][0-9]{2})/i,
      /IMPORTE\s*:?\s*S?\/?\.?\s*([0-9]+[.,][0-9]{2})/i,
      /([0-9]+[.,][0-9]{2})\s*SOLES/i
    ];
    
    for (const pattern of genericAmountPatterns) {
      const match = text.match(pattern);
      if (match && match[1]) {
        const cleanAmount = match[1].replace(",", ".");
        const possibleAmount = parseFloat(cleanAmount);
        
        // Verificar que el monto sea v√°lido y razonable
        if (!isNaN(possibleAmount) && possibleAmount > 0 && possibleAmount < 1000) {
          amount = possibleAmount;
          console.log(`Monto detectado con patr√≥n gen√©rico: ${amount}`);
          break;
        }
      }
    }
  }

  // Buscar direcci√≥n
  for (const pattern of addressPatterns) {
    const match = text.match(pattern);
    if (match) {
      address = match[1].trim();
      break;
    }
  }

  // Buscar vendedor/mesero
  for (const pattern of vendorPatterns) {
    const match = text.match(pattern);
    if (match) {
      vendor = match[1].trim();
      break;
    }
  }

  // Buscar fecha de compra
  for (const pattern of datePatterns) {
    const match = text.match(pattern);
    if (match) {
      purchaseDate = match[1];
      break;
    }
  }
  
  // Buscar n√∫mero de factura/boleta
  for (const pattern of invoiceNumberPatterns) {
    const match = text.match(pattern);
    if (match) {
      if (match.length > 2 && pattern.toString().includes('([0-9]{3})\\-([0-9]{6,})')) {
        // Para patrones como F001-000001 o B001-000001
        invoiceNumber = match[1] + '-' + match[2];
      } else {
        invoiceNumber = match[1];
      }
      break;
    }
  }

  // Intentar extraer productos/servicios
  // Primero intentamos con un patr√≥n m√°s espec√≠fico (cantidad, descripci√≥n, precio unitario, subtotal)
  const itemPattern1 = /(\d+\.?\d*)\s+(.+?)\s+(\d+[.,]\d{2})\s+(\d+[.,]\d{2})/g;
  let itemMatch;
  while ((itemMatch = itemPattern1.exec(text)) !== null) {
    items.push({
      quantity: parseFloat(itemMatch[1]),
      description: itemMatch[2].trim(),
      unitPrice: parseFloat(itemMatch[3].replace(",", ".")),
      subtotal: parseFloat(itemMatch[4].replace(",", "."))
    });
  }

  // Si no encontramos items con el primer patr√≥n, intentamos con uno m√°s simple
  if (items.length === 0) {
    // Patr√≥n alternativo: descripci√≥n seguida de precio
    const itemPattern2 = /([A-Za-z0-9\s]+)\s+(\d+[.,]\d{2})/g;
    while ((itemMatch = itemPattern2.exec(text)) !== null) {
      // Verificar que no sea el total u otro valor monetario ya capturado
      const description = itemMatch[1].trim();
      if (!/TOTAL|IMPORTE|SUBTOTAL|IGV|DESCUENTO/i.test(description)) {
        items.push({
          quantity: 1, // Asumimos cantidad 1 si no se especifica
          description: description,
          unitPrice: parseFloat(itemMatch[2].replace(",", ".")),
          subtotal: parseFloat(itemMatch[2].replace(",", "."))
        });
      }
    }
  }

  // Extraer ubicaci√≥n/local para cadenas con m√∫ltiples locales
  const locationPattern = /(LOCAL|SEDE|TIENDA|SUCURSAL)\s*:?\s*(.+?)(?=\n|$)/i;
  const locationMatch = text.match(locationPattern);
  if (locationMatch) {
    location = locationMatch[2].trim();
  }

  // Extraer el nombre del negocio del texto si es posible
  // No hardcodeamos negocios espec√≠ficos, sino que usamos la informaci√≥n extra√≠da
  // para buscar en la colecci√≥n businesses despu√©s

  // Si tenemos un nombre de negocio pero no un slug espec√≠fico, convertir a slug
  if (businessName && businessSlug === "default") {
    // Convertir a min√∫sculas y reemplazar espacios por guiones
    businessSlug = businessName.toLowerCase()
      .replace(/\s+/g, '-')           // Espacios a guiones
      .replace(/[^a-z0-9-]/g, '')     // Eliminar caracteres especiales
      .replace(/-+/g, '-')           // Eliminar guiones duplicados
      .replace(/^-|-$/g, '');        // Eliminar guiones al inicio y final
    
    // Si despu√©s de la limpieza queda vac√≠o, usar default
    if (!businessSlug) {
      businessSlug = "default";
    }
  }

  console.log("Extracci√≥n de datos:", { 
    ruc, 
    amount, 
    businessName, 
    businessSlug,
    address,
    vendor,
    items: items.length > 0 ? items : undefined,
    location,
    purchaseDate,
    invoiceNumber
  });
  
  return { 
    ruc, 
    amount, 
    amountInWords, // Incluir el monto en letras
    businessName, 
    businessSlug,
    address,
    vendor,
    items: items.length > 0 ? items : undefined,
    location,
    purchaseDate,
    invoiceNumber
  };
};

// Funci√≥n para verificar si un ticket es duplicado
async function isDuplicateReceipt(businessSlug, phoneNumber, amount, imageUrl, invoiceData = {}) {
  try {
    console.log(`üîç Verificando si el comprobante es duplicado para ${phoneNumber} en ${businessSlug}`);
    
    // Si tenemos n√∫mero de factura y RUC, verificar primero en la colecci√≥n de facturas
    if (invoiceData.invoiceNumber && invoiceData.ruc) {
      console.log(`üìù Verificando factura: ${invoiceData.invoiceNumber}, RUC: ${invoiceData.ruc}`);
      
      // Buscar en la colecci√≥n invoices si ya existe esta factura
      // Nota: Solo necesitamos verificar RUC y n√∫mero de factura, no el negocio,
      // ya que una factura con el mismo RUC y n√∫mero debe ser √∫nica en todo el sistema
      const invoiceQuery = db.collection("invoices")
        .where("ruc", "==", invoiceData.ruc)
        .where("invoiceNumber", "==", invoiceData.invoiceNumber);
      
      const invoiceSnapshot = await invoiceQuery.get();
      
      console.log(`Verificando duplicados en invoices: encontrados ${invoiceSnapshot.size} documentos`);
      
      if (!invoiceSnapshot.empty) {
        console.log(`‚ö†Ô∏è DUPLICADO ENCONTRADO: Factura con RUC=${invoiceData.ruc} y n√∫mero=${invoiceData.invoiceNumber} ya existe`);
        // Obtener detalles del duplicado para el log
        const duplicateDoc = invoiceSnapshot.docs[0].data();
        console.log(`Detalles del duplicado: Fecha=${duplicateDoc.timestamp}, Tel√©fono=${duplicateDoc.phoneNumber}`);
        return true;
      }
      
      console.log("‚úÖ No se encontr√≥ factura duplicada en la colecci√≥n invoices");
    } else {
      console.log("‚ö†Ô∏è No se proporcion√≥ RUC o n√∫mero de factura para verificaci√≥n precisa");
    }
    
    // Verificaci√≥n secundaria en la colecci√≥n de clientes (para compatibilidad con registros antiguos)
    const customerRef = db.collection("customers").doc(phoneNumber);
    const customerDoc = await customerRef.get();
    
    if (!customerDoc.exists) {
      console.log("Cliente no existe, no puede ser duplicado");
      return false;
    }
    
    const customerData = customerDoc.data();
    
    // Si el cliente no tiene compras en este negocio, no puede ser duplicado
    if (!customerData.businesses || !customerData.businesses[businessSlug]) {
      console.log("Cliente no tiene compras en este negocio, no puede ser duplicado");
      return false;
    }
    
    // Verificar si ya existe una compra con el mismo monto en la √∫ltima hora
    // Esto es una heur√≠stica simple para detectar duplicados cuando no tenemos RUC/n√∫mero de factura
    const purchases = customerData.businesses[businessSlug].purchases || [];
    
    // Convertir amount a n√∫mero para comparaci√≥n
    const amountNum = parseFloat(amount);
    
    // Verificar si hay alguna compra reciente con el mismo monto
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000); // 1 hora en milisegundos
    
    const duplicateFound = purchases.some(purchase => {
      // Verificar si el RUC y n√∫mero de factura coinciden (si est√°n disponibles)
      if (invoiceData.ruc && invoiceData.invoiceNumber && purchase.ruc && purchase.invoiceNumber) {
        if (purchase.ruc === invoiceData.ruc && purchase.invoiceNumber === invoiceData.invoiceNumber) {
          console.log("‚ö†Ô∏è DUPLICADO ENCONTRADO: RUC y n√∫mero de factura coinciden en historial del cliente");
          return true;
        }
      }
      
      // Verificar si el monto coincide (con un margen de error de 0.01)
      const amountMatch = Math.abs(purchase.amount - amountNum) < 0.01;
      
      // Verificar si la compra es reciente (menos de 1 hora)
      const timestamp = purchase.timestamp.toDate ? purchase.timestamp.toDate() : purchase.timestamp;
      const isRecent = timestamp > oneHourAgo;
      
      return amountMatch && isRecent;
    });
    
    if (duplicateFound) {
      console.log("‚ö†Ô∏è DUPLICADO ENCONTRADO: Se encontr√≥ un recibo duplicado basado en el monto y tiempo");
      return true;
    }
    
    console.log("‚úÖ No se encontr√≥ un recibo duplicado");
    return false;
  } catch (error) {
    console.error("‚ùå Error al verificar duplicados:", error);
    // En caso de error, asumimos que no es duplicado para no bloquear al usuario
    return false;
  }
}

// Funci√≥n para validar tiempo entre compras
async function validateTimeBetweenPurchases(
  businessSlug,
  phoneNumber,
  timeLimit
) {
  const customerRef = db.collection("customers").doc(phoneNumber);
  const customerDoc = await customerRef.get();

  if (!customerDoc.exists) {
    return { valid: true };
  }

  const customerData = customerDoc.data();
  const businessData = customerData.businesses?.[businessSlug];

  if (!businessData?.lastVisit) {
    return { valid: true };
  }

  const lastVisitTime = businessData.lastVisit.toDate();
  const timeElapsed = Date.now() - lastVisitTime.getTime();

  if (timeElapsed < timeLimit) {
    const minutesRemaining = Math.ceil((timeLimit - timeElapsed) / 60000);
    return {
      valid: false,
      message: `Por favor espera ${minutesRemaining} minutos antes de registrar otra compra.`,
    };
  }

  return { valid: true };
}

// Funci√≥n para procesar im√°genes con Vision API
async function processReceiptImage(imageData) {
  try {
    console.log("üîç Procesando imagen con Vision API...");
    
    // Verificar si recibimos un buffer o una URL
    let request;
    if (Buffer.isBuffer(imageData)) {
      console.log("üìä Procesando imagen desde buffer");
      request = {
        image: {
          content: imageData
        }
      };
    } else if (typeof imageData === 'string') {
      console.log("üîó Procesando imagen desde URL");
      request = {
        image: {
          source: {
            imageUri: imageData
          }
        }
      };
    } else {
      throw new Error("Formato de imagen no v√°lido");
    }
    
    // Realizar an√°lisis de la imagen con Vision API
    const [result] = await visionClient.textDetection(request);
    const detections = result.textAnnotations;

    if (!detections || detections.length === 0) {
      console.log("No se detect√≥ texto en la imagen");
      return { success: false, error: "No se detect√≥ texto en la imagen" };
    }

    // El primer elemento contiene todo el texto detectado
    const text = detections[0].description;
    console.log("Texto detectado:", text);

    // Extraer informaci√≥n relevante (RUC, monto, etc.)
    const { ruc, amount } = extractRUCAndAmount(text);

    return {
      success: true,
      text,
      ruc,
      amount,
    };
  } catch (error) {
    console.error("Error procesando imagen:", error);
    return { success: false, error: error.message };
  }
}

// Funci√≥n para registrar la compra en la base de datos
async function registerPurchase(businessSlug, phoneNumber, amount, imageUrl, additionalData = {}) {
  try {
    console.log(`Registrando compra para ${phoneNumber} en ${businessSlug} por ${amount}`);
    
    // Obtener informaci√≥n del usuario para business_customers
    let userId = null;
    let userName = "Cliente";
    
    try {
      const userRef = db.collection("users").where("phone", "==", phoneNumber).limit(1);
      const userSnapshot = await userRef.get();
      
      if (!userSnapshot.empty) {
        userId = userSnapshot.docs[0].id;
        userName = userSnapshot.docs[0].data().displayName || "Cliente";
      }
    } catch (error) {
      console.error("Error al buscar usuario:", error);
      // Continuamos aunque no encontremos el usuario
    }
    
    // Si tenemos n√∫mero de factura y RUC, registrar en la colecci√≥n invoices
    // para evitar duplicados en el futuro
    if (additionalData.invoiceNumber && additionalData.ruc) {
      try {
        console.log(`Registrando factura en invoices: ${additionalData.invoiceNumber}, RUC: ${additionalData.ruc}`);
        
        await db.collection("invoices").add({
          businessSlug,
          ruc: additionalData.ruc,
          invoiceNumber: additionalData.invoiceNumber,
          amount: parseFloat(amount),
          amountInWords: additionalData.amountInWords || null, // Guardar el monto en letras
          phoneNumber,
          timestamp: new Date(),
          receiptDate: additionalData.purchaseDate || null,
          whatsappDate: new Date(),
          items: additionalData.items || [],
          address: additionalData.address || null,
          vendor: additionalData.vendor || null,
          location: additionalData.location || null,
          businessName: additionalData.businessName || null
        });
        
        console.log(`‚úÖ Factura registrada en invoices`);
      } catch (error) {
        console.error("Error al registrar factura en invoices:", error);
        // Continuamos con el proceso aunque falle este registro
      }
    }
    
    // 1. Registrar en customers (historial del cliente)
    const customerRef = db.collection("customers").doc(phoneNumber);
    const customerDoc = await customerRef.get();

    let customerData = {};
    if (customerDoc.exists) {
      customerData = customerDoc.data();
    }

    if (!customerData.businesses) {
      customerData.businesses = {};
    }

    if (!customerData.businesses[businessSlug]) {
      // Si es la primera vez que este cliente visita este negocio
      customerData.businesses[businessSlug] = {
        visits: 0,
        purchases: [],
        lastVisit: new Date(),
        firstVisit: new Date(),
        purchaseCount: 0
      };
    }

    // Incrementar contador de compras
    if (typeof customerData.businesses[businessSlug].purchaseCount !== 'number') {
      customerData.businesses[businessSlug].purchaseCount = 0;
    }
    customerData.businesses[businessSlug].purchaseCount += 1;
    
    // Actualizar visitas (mantener el valor existente si ya existe)
    if (typeof customerData.businesses[businessSlug].visits !== 'number') {
      customerData.businesses[businessSlug].visits = 1;
    } else {
      customerData.businesses[businessSlug].visits += 1;
    }
    
    // Actualizar fecha de √∫ltima visita
    customerData.businesses[businessSlug].lastVisit = new Date();

    // Agregar compra con todos los datos disponibles
    const purchase = {
      amount: parseFloat(amount),
      timestamp: new Date(),  // Fecha de registro por WhatsApp
      receiptUrl: imageUrl,
      verified: true,
      // Datos de la factura
      ...(additionalData.invoiceNumber ? { invoiceNumber: additionalData.invoiceNumber } : {}),
      ...(additionalData.ruc ? { ruc: additionalData.ruc } : {}),
      ...(additionalData.purchaseDate ? { purchaseDate: additionalData.purchaseDate } : {}),
      // Datos del local
      ...(additionalData.businessName ? { businessName: additionalData.businessName } : {}),
      ...(additionalData.address ? { address: additionalData.address } : {}),
      ...(additionalData.location ? { location: additionalData.location } : {}),
      // Datos del servicio
      ...(additionalData.vendor ? { vendor: additionalData.vendor } : {}),
      // Items comprados
      ...(additionalData.items && additionalData.items.length > 0 ? { items: additionalData.items } : {})
    };

    customerData.businesses[businessSlug].purchases.push(purchase);

    // Actualizar contador de compras y monto total
    customerData.businesses[businessSlug].purchaseCount = customerData.businesses[businessSlug].purchases.length;
    
    // Calcular monto total gastado sumando todas las compras
    let totalSpent = 0;
    for (const purchase of customerData.businesses[businessSlug].purchases) {
      if (purchase.amount && !isNaN(purchase.amount)) {
        totalSpent += parseFloat(purchase.amount);
      }
    }
    
    // Asegurar que el valor sea un n√∫mero v√°lido
    customerData.businesses[businessSlug].totalSpent = isNaN(totalSpent) ? 0 : totalSpent;
    
    console.log(`Total gastado calculado para ${phoneNumber} en ${businessSlug}: ${customerData.businesses[businessSlug].totalSpent}`);

    // Actualizar o crear documento del cliente
    await customerRef.set(customerData, { merge: true });
    
    // 2. Registrar en business_customers para que el negocio pueda ver sus clientes
    try {
      if (businessSlug) {
        const businessCustomerRef = db.collection("business_customers")
          .doc(`${businessSlug}_${phoneNumber.replace(/[^a-zA-Z0-9]/g, "")}`);
        
        // Verificar si ya existe el registro
        const businessCustomerDoc = await businessCustomerRef.get();
        
        // Calcular el monto total gastado correctamente
        let totalSpent = parseFloat(amount);
        
        if (businessCustomerDoc.exists) {
          const existingData = businessCustomerDoc.data();
          // Si ya existe un totalSpent, sumamos el nuevo monto
          if (existingData.totalSpent && !isNaN(existingData.totalSpent)) {
            totalSpent = existingData.totalSpent + parseFloat(amount);
          }
        }
        
        const businessCustomerData = {
          businessSlug,
          phoneNumber,
          userId,
          customerName: userName,
          lastVisit: new Date(),
          totalVisits: customerData.businesses[businessSlug].visits,
          totalSpent: totalSpent, // Usar el valor calculado
          lastPurchase: {
            amount: parseFloat(amount),
            timestamp: new Date(),
            ...(additionalData.invoiceNumber ? { invoiceNumber: additionalData.invoiceNumber } : {}),
            ...(additionalData.ruc ? { ruc: additionalData.ruc } : {}),
            ...(additionalData.purchaseDate ? { purchaseDate: additionalData.purchaseDate } : {}),
            ...(additionalData.address ? { address: additionalData.address } : {}),
            ...(additionalData.vendor ? { vendor: additionalData.vendor } : {}),
            ...(additionalData.items ? { items: additionalData.items } : [])
          },
          updatedAt: new Date()
        };
        
        // Si es la primera vez, agregar fecha de creaci√≥n
        if (!businessCustomerDoc.exists) {
          businessCustomerData.createdAt = new Date();
          businessCustomerData.firstVisit = new Date();
        } else {
          // Mantener la fecha de primera visita si ya existe
          const existingData = businessCustomerDoc.data();
          if (existingData.firstVisit) {
            businessCustomerData.firstVisit = existingData.firstVisit;
          }
        }
        
        await businessCustomerRef.set(businessCustomerData, { merge: true });
        console.log(`Cliente registrado en business_customers para ${businessSlug} con totalSpent=${totalSpent}`);
      }
    } catch (error) {
      console.error("Error al registrar en business_customers:", error);
      // Continuamos aunque falle este registro
    }
    
    // 3. Registrar en business_purchases para el historial de compras del negocio
    try {
      if (businessSlug) {
        // Crear un registro en business_purchases
        // Crear un ID personalizado usando RUC + n√∫mero de factura si est√°n disponibles
        let purchaseId = null;
        if (additionalData.ruc && additionalData.invoiceNumber) {
          purchaseId = `${additionalData.ruc}-${additionalData.invoiceNumber}`;
          console.log(`Usando ID personalizado para purchase: ${purchaseId}`);
        }
        
        // Referencia a la colecci√≥n
        const purchaseRef = purchaseId ? 
          db.collection("business_purchases").doc(purchaseId) : 
          db.collection("business_purchases").doc();
        
        // Datos a guardar
        const purchaseData = {
          businessSlug,
          phoneNumber,
          customerName: userName,
          amount: parseFloat(amount),
          timestamp: new Date(),
          // Datos de la factura
          ...(additionalData.invoiceNumber ? { invoiceNumber: additionalData.invoiceNumber } : {}),
          ...(additionalData.ruc ? { ruc: additionalData.ruc } : {}),
          // Guardar AMBAS fechas: la fecha de emisi√≥n del recibo y la fecha de registro
          ...(additionalData.purchaseDate ? { 
            issueDate: additionalData.purchaseDate, // Fecha de emisi√≥n del recibo
            purchaseDate: additionalData.purchaseDate // Mantener para compatibilidad
          } : {}),
          shareDate: new Date(), // Fecha en que se comparti√≥ el recibo por WhatsApp
          ...(additionalData.amountInWords ? { amountInWords: additionalData.amountInWords } : {}),
          // Guardar el texto completo extra√≠do por Google Vision como respaldo
          ...(additionalData.fullText ? { fullText: additionalData.fullText } : {}),
          // Datos del local
          ...(additionalData.businessName ? { businessName: additionalData.businessName } : {}),
          ...(additionalData.address ? { address: additionalData.address } : {}),
          ...(additionalData.location ? { location: additionalData.location } : {}),
          // Datos del servicio
          ...(additionalData.vendor ? { vendor: additionalData.vendor } : {}),
          // Items comprados
          ...(additionalData.items && additionalData.items.length > 0 ? { items: additionalData.items } : {})
        };
        
        // Guardar el documento
        await purchaseRef.set(purchaseData);
        console.log(`Compra registrada en business_purchases con ID: ${purchaseRef.id}`);
        
        console.log(`Compra registrada en business_purchases para ${businessSlug}`);
      }
    } catch (error) {
      console.error("Error al registrar en business_purchases:", error);
      // Continuamos aunque falle este registro
    }

    return {
      success: true,
      visits: customerData.businesses[businessSlug].visits,
      purchaseCount: customerData.businesses[businessSlug].purchaseCount,
      totalSpent
    };
  } catch (error) {
    console.error("Error registrando compra:", error);
    return { success: false, error: error.message };
  }
}
// Funci√≥n para enviar mensaje a trav√©s de WhatsApp API
async function sendWhatsAppMessage(phoneNumber, message, phoneNumberId) {
  try {
    // Acceder directamente a las variables de entorno proporcionadas por los secretos
    const apiToken = process.env.WHATSAPP_API_TOKEN;
    const phoneId = phoneNumberId || process.env.WHATSAPP_PHONE_NUMBER_ID;

    console.log("üì≤ Enviando mensaje a:", phoneNumber);
    console.log("üí¨ Contenido del mensaje:", message);
    console.log(
      "üîë Usando token de API de WhatsApp:",
      apiToken ? apiToken.substring(0, 10) + "..." : "No disponible"
    );
    console.log("üì± Usando ID de n√∫mero de tel√©fono:", phoneId);

    if (!apiToken) {
      console.error("‚ùå Token de API de WhatsApp no configurado");
      throw new Error("Token de API de WhatsApp no configurado");
    }

    // Formatear el n√∫mero de tel√©fono si es necesario
    if (phoneNumber.startsWith("+")) {
      phoneNumber = phoneNumber.substring(1);
    }

    // Enviar mensaje a trav√©s de la API de WhatsApp
    console.log("üîÑ Realizando solicitud a la API de WhatsApp...");
    const response = await axios({
      method: "POST",
      url: `https://graph.facebook.com/v18.0/${phoneId}/messages`,
      headers: {
        Authorization: `Bearer ${apiToken}`,
        "Content-Type": "application/json",
      },
      data: {
        messaging_product: "whatsapp",
        recipient_type: "individual",
        to: phoneNumber,
        type: "text",
        text: {
          preview_url: false,
          body: message,
        },
      },
    });

    console.log(
      "‚úÖ Mensaje enviado correctamente:",
      JSON.stringify(response.data, null, 2)
    );
    return { success: true, data: response.data };
  } catch (error) {
    console.error("‚ùå Error enviando mensaje de WhatsApp:", error.message);
    console.error(
      "üìã Detalles del error:",
      error.response
        ? JSON.stringify(error.response.data, null, 2)
        : "No hay datos de respuesta"
    );
    return { success: false, error: error.message };
  }
}

// Funci√≥n para descargar media de WhatsApp API
async function downloadWhatsAppMedia(mediaId) {
  try {
    console.log("üì• Iniciando descarga de media con ID:", mediaId);

    // Usar las constantes globales definidas en el archivo en lugar de variables de entorno
    const apiToken = whatsappApiToken;
    const phoneNumberId = whatsappPhoneNumberId;

    console.log(
      "üîë Usando token de API de WhatsApp (download):",
      apiToken ? apiToken.substring(0, 10) + "..." : "No disponible"
    );

    if (!apiToken) {
      console.error("‚ùå Token de API de WhatsApp no configurado");
      throw new Error("Token de API de WhatsApp no configurado");
    }

    // Primero obtenemos la URL del media
    console.log("üîÑ Obteniendo URL del media...");
    const mediaResponse = await axios({
      method: "GET",
      url: `${WHATSAPP_API_URL}/${mediaId}`,
      headers: {
        Authorization: `Bearer ${apiToken}`,
      },
    });

    if (!mediaResponse.data || !mediaResponse.data.url) {
      console.error("‚ùå No se pudo obtener la URL del media", mediaResponse.data);
      throw new Error("No se pudo obtener la URL del media");
    }

    console.log("‚úÖ URL del media obtenida:", mediaResponse.data.url);
    const mediaUrl = mediaResponse.data.url;

    // Luego descargamos el contenido del media
    console.log("üîÑ Descargando contenido del media...");
    const mediaContent = await axios({
      method: "GET",
      url: mediaUrl,
      headers: {
        Authorization: `Bearer ${apiToken}`,
      },
      responseType: "arraybuffer",
    });

    console.log("‚úÖ Contenido del media descargado correctamente");

    // Devolver el buffer de la imagen para procesamiento directo con Vision API
    // en lugar de usar la URL que podr√≠a no ser accesible para Google Vision
    return {
      success: true,
      data: mediaContent.data,
      contentType: mediaContent.headers["content-type"],
      buffer: mediaContent.data, // Incluir el buffer para procesamiento con Vision API
    };
  } catch (error) {
    console.error("‚ùå Error descargando media:", error.message);
    console.error(
      "üìã Detalles del error:",
      error.response
        ? JSON.stringify(error.response.data, null, 2)
        : "No hay datos de respuesta"
    );
    return {
      success: false,
      error: error.message,
    };
  }
}

// Middleware para verificar firma de las solicitudes de WhatsApp API
async function verifyWhatsAppSignature(req, res, next) {
  try {
    // Usar el valor predeterminado si la variable de entorno no est√° disponible
    const appSecret =
      process.env.WHATSAPP_APP_SECRET || "09353d1301e356b0cdcba78d2a9c7639";

    console.log(
      "Usando secreto de la aplicaci√≥n:",
      appSecret ? appSecret.substring(0, 5) + "..." : "No disponible"
    );

    // Verificar si estamos en modo desarrollo (omitir verificaci√≥n de firma)
    const isDevelopment = process.env.NODE_ENV !== "production";

    console.log("Estamos en modo desarrollo:", isDevelopment);

    if (isDevelopment) {
      console.log("Modo desarrollo: Omitiendo verificaci√≥n de firma");
      return next();
    }

    console.log("Verificando firma con secreto de la aplicaci√≥n");

    const signature = req.headers["x-hub-signature-256"];
    if (!signature) {
      console.warn(
        "No se encontr√≥ la firma en los headers:",
        JSON.stringify(req.headers)
      );
      return res.status(401).send("No signature found");
    }

    const [algorithm, expectedHash] = signature.split("=");
    if (algorithm !== "sha256") {
      console.warn("Algoritmo de firma no soportado:", algorithm);
      return res.status(401).send("Unsupported signature algorithm");
    }

    // Mostrar el cuerpo de la solicitud para depuraci√≥n (ten cuidado con datos sensibles)
    console.log("Cuerpo de la solicitud:", JSON.stringify(req.body));

    const body = JSON.stringify(req.body);
    const hmac = crypto.createHmac("sha256", appSecret);
    hmac.update(body);
    const calculatedHash = hmac.digest("hex");

    console.log("Hash calculado completo:", calculatedHash);
    console.log("Hash esperado completo:", expectedHash);

    if (calculatedHash !== expectedHash) {
      console.warn("Firma inv√°lida");
      return res.status(401).send("Invalid signature");
    }

    next();
  } catch (error) {
    console.error("Error verificando firma:", error);
    res.status(500).send("Error verifying signature");
  }
}

// Ruta para verificaci√≥n del webhook de WhatsApp (ruta /webhook)
whatsappApiApp.get("/webhook", (req, res) => {
  const mode = req.query["hub.mode"];
  const token = req.query["hub.verify_token"];
  const challenge = req.query["hub.challenge"];
  const verifyToken = whatsappVerifyToken;

  console.log("Usando token de verificaci√≥n:", verifyToken);

  if (mode === "subscribe" && token === verifyToken) {
    console.log("Webhook verificado correctamente");
    res.status(200).send(challenge);
  } else {
    console.error("Verificaci√≥n fallida. Token incorrecto.");
    res.status(403).send("Verificaci√≥n fallida");
  }
});

// Ruta para verificaci√≥n del webhook de WhatsApp (ruta ra√≠z /)
whatsappApiApp.get("/", (req, res) => {
  const mode = req.query["hub.mode"];
  const token = req.query["hub.verify_token"];
  const challenge = req.query["hub.challenge"];
  const verifyToken = whatsappVerifyToken;

  console.log("Usando token de verificaci√≥n (ruta ra√≠z):", verifyToken);

  if (mode === "subscribe" && token === verifyToken) {
    console.log("Webhook verificado correctamente en ruta ra√≠z");
    res.status(200).send(challenge);
  } else {
    console.error("Verificaci√≥n fallida en ruta ra√≠z. Token incorrecto.");
    res.status(403).send("Verificaci√≥n fallida");
  }
});

// Ruta para procesar mensajes entrantes de WhatsApp en la ruta ra√≠z (/)
// En tu ruta POST principal, modifica la parte de procesamiento de mensajes:
whatsappApiApp.post("/", verifyWhatsAppSignature, async (req, res) => {
  try {
    // Responder r√°pidamente para evitar timeouts
    res.status(200).send("EVENT_RECEIVED");

    const body = req.body;
    console.log("üîç Mensaje recibido:", JSON.stringify(body, null, 2));

    // Verificar que sea un mensaje de WhatsApp
    if (!body.object || body.object !== "whatsapp_business_account") {
      console.log("‚ùå Evento no soportado:", body.object);
      return;
    }

    console.log("‚úÖ Objeto WhatsApp v√°lido, procesando entradas...");

    // Procesar cada entrada
    for (const entry of body.entry) {
      console.log("üìù Procesando entrada:", JSON.stringify(entry, null, 2));

      // Procesar cada cambio
      for (const change of entry.changes) {
        console.log("üîÑ Procesando cambio:", change.field);

        if (change.field !== "messages") {
          console.log("‚ö†Ô∏è Campo no soportado:", change.field);
          continue;
        }

        const value = change.value;
        console.log("üìã Valor del cambio:", JSON.stringify(value, null, 2));

        // Guardar la metadata para usar en respuestas
        const metadata = value.metadata || {};

        // Procesar cada mensaje entrante
        if (value.messages && value.messages.length > 0) {
          for (const message of value.messages) {
            const from = message.from;
            console.log(
              `üì± Mensaje recibido de ${from} con ID ${message.id} (tipo: ${message.type})`
            );

            // Buscar o crear usuario
            console.log("üîç Buscando o creando usuario...");
            const user = await findOrCreateUser(from);
            console.log(
              "üë§ Usuario encontrado/creado:",
              JSON.stringify(user, null, 2)
            );

            // Procesar seg√∫n el tipo de mensaje
            if (message.type === "image") {
              console.log("üñºÔ∏è Procesando mensaje de imagen...");
              await processImageMessage(message, user, {}, metadata);
            } else if (message.type === "text") {
              console.log("üìù Procesando mensaje de texto...");
              await processTextMessage(message, user, {}, metadata);
            } else {
              console.log(`‚ö†Ô∏è Tipo de mensaje no soportado: ${message.type}`);
              await sendWhatsAppMessage(
                from,
                "Lo siento, solo puedo procesar im√°genes de facturas o comandos de texto. Env√≠a 'ayuda' para m√°s informaci√≥n.",
                metadata.phone_number_id
              );
            }
          }
        } else {
          console.log("‚ö†Ô∏è No hay mensajes en el cambio");
        }
      }
    }
  } catch (error) {
    console.error("‚ùå Error procesando webhook:", error);
  }
});

// Ruta para procesar mensajes entrantes de WhatsApp (ruta /webhook)
whatsappApiApp.post("/webhook", verifyWhatsAppSignature, async (req, res) => {
  try {
    // Responder r√°pidamente para evitar timeouts
    res.status(200).send("EVENT_RECEIVED");

    const body = req.body;

    // Verificar que sea un mensaje de WhatsApp
    if (!body.object || body.object !== "whatsapp_business_account") {
      console.log("Evento no soportado:", body.object);
      return;
    }

    // Obtener la configuraci√≥n de WhatsApp desde Firestore
    const configSnapshot = await db
      .collection("system")
      .doc("whatsapp_config")
      .get();
    const whatsappConfig = configSnapshot.exists ? configSnapshot.data() : {};

    // Procesar cada entrada (puede haber m√∫ltiples en un solo webhook)
    for (const entry of body.entry) {
      // Procesar cada cambio en los mensajes
      for (const change of entry.changes) {
        if (change.field !== "messages") {
          continue;
        }

        const value = change.value;

        // Verificar si hay mensajes
        if (!value.messages || value.messages.length === 0) {
          continue;
        }

        // Obtener informaci√≥n del contacto
        const contacts = value.contacts || [];
        if (contacts.length === 0) {
          console.log("No se encontr√≥ informaci√≥n del contacto");
          continue;
        }

        const contact = contacts[0];
        const phone = contact.wa_id;
        const name = contact.profile?.name || "Cliente";

        console.log(`Mensaje recibido de ${name} (${phone})`);

        // Buscar o crear usuario
        let user = await findOrCreateUser(phone, name);

        // Procesar cada mensaje
        for (const message of value.messages) {
          const messageId = message.id;
          const timestamp = message.timestamp;

          console.log(
            `Procesando mensaje ${messageId} del tipo ${message.type}`
          );

          // Procesar seg√∫n el tipo de mensaje
          switch (message.type) {
            case "image":
              // Procesar imagen (comprobante de pago)
              await processImageMessage(message, user, whatsappConfig);
              break;

            case "text":
              // Procesar texto (comandos o consultas)
              await processTextMessage(message, user, whatsappConfig);
              break;

            default:
              // Mensaje no soportado
              await sendWhatsAppMessage(
                phone,
                "Para registrar un consumo, env√≠a una foto del comprobante de pago. Para consultar tus puntos, env√≠a la palabra 'puntos'."
              );
          }
        }
      }
    }
  } catch (error) {
    console.error("Error procesando webhook:", error);
  }
});

// Funci√≥n para buscar o crear un usuario
async function findOrCreateUser(phone, name) {
  try {
    // Buscar usuario por tel√©fono
    const usersSnapshot = await db
      .collection("users")
      .where("phone", "==", phone)
      .limit(1)
      .get();

    // Si el usuario existe, retornarlo
    if (!usersSnapshot.empty) {
      const userData = usersSnapshot.docs[0].data();
      return {
        id: usersSnapshot.docs[0].id,
        ...userData,
      };
    }

    // Si no existe, crear un nuevo usuario
    const newUser = {
      displayName: name,
      phone: phone,
      role: "business-client",
      registeredVia: "whatsapp",
      disabled: false,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const userRef = await db.collection("users").add(newUser);

    console.log(`Nuevo usuario creado: ${userRef.id}`);

    return {
      id: userRef.id,
      ...newUser,
    };
  } catch (error) {
    console.error("Error buscando/creando usuario:", error);
    throw error;
  }
}

// Funci√≥n para procesar mensajes de imagen
async function processImageMessage(message, user, whatsappConfig, metadata) {
  try {
    console.log("üñºÔ∏è Iniciando procesamiento de imagen");
    const imageId = message.image.id;
    console.log("üÜî ID de imagen:", imageId);
    
    // Normalizar n√∫mero de tel√©fono (asegurarnos de que tenga el signo +)
    const normalizedPhone = user.phone.startsWith("+") ? user.phone : "+" + user.phone;
    console.log("üì± N√∫mero de tel√©fono normalizado:", normalizedPhone);

    // Enviar mensaje inmediato de confirmaci√≥n
    await sendWhatsAppMessage(
      user.phone,
      "Recibimos tu imagen. Estamos proces√°ndola, por favor espera un momento...",
      metadata?.phone_number_id
    );

    // Descargar la imagen
    console.log("üì• Descargando imagen...");
    const mediaResult = await downloadWhatsAppMedia(imageId);
    if (!mediaResult.success) {
      console.error("‚ùå Error al descargar la imagen:", mediaResult.error);
      await sendWhatsAppMessage(
        user.phone,
        "Lo sentimos, no pudimos procesar tu imagen. Por favor, intenta nuevamente.",
        metadata?.phone_number_id
      );
      return;
    }
    console.log("‚úÖ Imagen descargada correctamente");

    // Procesar la imagen con Google Vision
    console.log("üîç Procesando la imagen con Google Vision...");
    // Usar el buffer de la imagen en lugar de la URL
    const visionResult = await processReceiptImage(mediaResult.buffer);

    if (!visionResult.success) {
      console.error(
        "‚ùå Error al procesar la imagen con Vision API:",
        visionResult.error
      );
      await sendWhatsAppMessage(
        user.phone,
        "No pudimos detectar texto en la imagen. Por favor, env√≠a una foto m√°s clara del comprobante.",
        metadata?.phone_number_id
      );
      return;
    }

    // Extraer informaci√≥n relevante del texto
    const text = visionResult.text;
    const extractedData = extractRUCAndAmount(text);
    
    // Guardar el texto completo extra√≠do por Google Vision
    extractedData.fullText = text;

    console.log(`Informaci√≥n extra√≠da: ${JSON.stringify(extractedData)}`);

    // Verificar si se pudo extraer la informaci√≥n necesaria
    if (!extractedData.ruc || !extractedData.amount) {
      console.log(`‚ö†Ô∏è No se pudo extraer RUC o monto del texto`);
      await sendWhatsAppMessage(
        user.phone,
        "No pude identificar correctamente la informaci√≥n del comprobante. Por favor, aseg√∫rate de que la imagen sea clara y muestre el RUC y el monto total.",
        metadata?.phone_number_id
      );
      return;
    }

    console.log("üí∞ Monto detectado:", extractedData.amount);
    console.log("üè¢ Negocio detectado:", extractedData.businessName || "No detectado");
    console.log("üî§ RUC detectado:", extractedData.ruc || "No detectado");
    console.log("üóìÔ∏è Fecha de emisi√≥n:", extractedData.purchaseDate || "No detectada");
    
    // Buscar el negocio en la colecci√≥n businesses usando el RUC o el nombre
    let businessSlug = "default";
    let businessInfo = null;
    
    // Primero intentamos buscar por RUC si est√° disponible
    if (visionResult.ruc) {
      console.log("üîç Buscando negocio por RUC:", visionResult.ruc);
      const businessByRucSnapshot = await db.collection("businesses")
        .where("ruc", "==", visionResult.ruc)
        .limit(1)
        .get();
      
      if (!businessByRucSnapshot.empty) {
        businessInfo = businessByRucSnapshot.docs[0].data();
        businessSlug = businessInfo.slug || businessByRucSnapshot.docs[0].id;
        console.log("‚úÖ Negocio encontrado por RUC:", businessInfo.name);
      }
    }
    
    // Si no encontramos por RUC, intentamos buscar por nombre si est√° disponible
    if (!businessInfo && visionResult.businessName) {
      console.log("üîç Buscando negocio por nombre:", visionResult.businessName);
      // Buscar de forma case-insensitive (convertimos a min√∫sculas)
      const businessName = visionResult.businessName.toLowerCase();
      const businessesSnapshot = await db.collection("businesses").get();
      
      // Recorremos todos los negocios buscando coincidencias parciales en el nombre
      for (const doc of businessesSnapshot.docs) {
        const business = doc.data();
        if (business.name && business.name.toLowerCase().includes(businessName) ||
            businessName.includes(business.name.toLowerCase())) {
          businessInfo = business;
          businessSlug = business.slug || doc.id;
          console.log("‚úÖ Negocio encontrado por nombre:", business.name);
          break;
        }
      }
    }
    
    // Si no encontramos el negocio, usamos el valor por defecto
    if (!businessInfo) {
      console.log("‚ö†Ô∏è No se encontr√≥ el negocio en la base de datos. Usando default.");
    }

    // Verificar si es un ticket duplicado usando RUC y n√∫mero de factura
    const isDuplicate = await isDuplicateReceipt(
      businessSlug,
      normalizedPhone,
      extractedData.amount,
      extractedData.ruc && extractedData.invoiceNumber ? 
        `${extractedData.ruc}-${extractedData.invoiceNumber}` : // Usar RUC + n√∫mero de factura como ID
        "receipt_" + Date.now(), // Identificador √∫nico para la imagen si no hay RUC o n√∫mero de factura
      {
        ruc: extractedData.ruc,
        invoiceNumber: extractedData.invoiceNumber
      }
    );

    if (isDuplicate) {
      console.log("‚ö†Ô∏è Comprobante duplicado detectado");
      await sendWhatsAppMessage(
        user.phone,
        "Este comprobante parece haber sido registrado anteriormente. Por favor, env√≠a un comprobante diferente.",
        metadata?.phone_number_id
      );
      return;
    }

    // Validar tiempo entre compras
    const timeValidation = await validateTimeBetweenPurchases(
      businessSlug,
      user.phone,
      30 * 60 * 1000 // 30 minutos entre compras
    );

    if (!timeValidation.valid) {
      console.log("‚è±Ô∏è Validaci√≥n de tiempo entre compras fallida");
      await sendWhatsAppMessage(
        user.phone,
        timeValidation.message,
        metadata?.phone_number_id
      );
      return;
    }

    // Usar la direcci√≥n detectada en la factura como prioridad
    // Si no est√° disponible, usar la direcci√≥n del negocio de la base de datos
    const address = extractedData.address || (businessInfo ? businessInfo.address : null);
    
    // Preparar datos adicionales para el registro
    const additionalData = {
      // Datos de la factura
      invoiceNumber: extractedData.invoiceNumber,
      ruc: extractedData.ruc,
      purchaseDate: extractedData.purchaseDate, // Fecha de emisi√≥n del recibo
      businessName: extractedData.businessName || (businessInfo ? businessInfo.name : null),
      address: extractedData.address,
      location: extractedData.location,
      vendor: extractedData.vendor,
      items: extractedData.items,
      amountInWords: extractedData.amountInWords,
      fullText: extractedData.fullText, // Texto completo extra√≠do por Google Vision
      
      // Incluir datos adicionales del negocio si los tenemos
      businessInfo: businessInfo || null
    };
    
    console.log("üìù Datos adicionales detectados:", additionalData);
    
    const purchaseResult = await registerPurchase(
      businessSlug,
      normalizedPhone, // Usar el n√∫mero con el signo +
      visionResult.amount,
      "receipt_" + Date.now(), // Usar un identificador √∫nico para la compra
      additionalData
    );
    
    if (!purchaseResult.success) {
      console.error("‚ùå Error al registrar la compra:", purchaseResult.error);
      await sendWhatsAppMessage(
        user.phone,
        "Lo sentimos, hubo un problema al registrar tu compra. Por favor, intenta nuevamente m√°s tarde.",
        metadata?.phone_number_id
      );
      return;
    }
    
    console.log("üí∞ Compra registrada con monto:", visionResult.amount, "Total gastado:", purchaseResult.totalSpent);

    // Obtener informaci√≥n actualizada del cliente
    const customerRef = db.collection("customers").doc(normalizedPhone);
    const customerDoc = await customerRef.get();
    const customerData = customerDoc.data();
    const businessData = customerData.businesses[businessSlug];

    // Construir URL de la tarjeta de fidelidad
    const cardUrl = `https://asiduo.club/${businessSlug}/${normalizedPhone}`;
    
    // Obtener nombre del negocio para mostrar
    const businessNameDisplay = businessInfo ? businessInfo.name : (extractedData.businessName || businessSlug);
    
    // Formatear productos si hay items detectados
    let itemsText = '';
    if (extractedData.items && extractedData.items.length > 0) {
      itemsText = '\n\nProductos detectados:\n';
      extractedData.items.slice(0, 3).forEach(item => {
        itemsText += `- ${item.quantity} x ${item.description} (S/ ${item.subtotal})\n`;
      });
      
      if (extractedData.items.length > 3) {
        itemsText += `... y ${extractedData.items.length - 3} productos m√°s\n`;
      }
    }
    
    // Formatear fecha si est√° disponible
    const dateText = extractedData.purchaseDate ? 
      `\nFecha: ${extractedData.purchaseDate}` : '';
    
    // Formatear direcci√≥n si est√° disponible
    // SIEMPRE usar la direcci√≥n extra√≠da del recibo (donde se realiz√≥ la compra)
    // Forzar la extracci√≥n de la direcci√≥n del recibo
    let addressToShow = '';
    
    // Buscar direcci√≥n en el texto del recibo
    if (extractedData.address) {
      addressToShow = extractedData.address;
      console.log(`Usando direcci√≥n extra√≠da del recibo: ${addressToShow}`);
    } else {
      // Intentar extraer la direcci√≥n del texto completo si no se detect√≥ anteriormente
      const addressPatterns = [
        /DIRECCION\s*:?\s*(.+?)(?=\n|$)/i,
        /DOMICILIO FISCAL\s*:?\s*(.+?)(?=\n|$)/i,
        /DIR\s*:?\s*(.+?)(?=\n|$)/i,
        /AV\.?\s+([^\n]+?)(?=\n|$)/i,
        /JR\.?\s+([^\n]+?)(?=\n|$)/i,
        /CALLE\s+([^\n]+?)(?=\n|$)/i
      ];
      
      for (const pattern of addressPatterns) {
        const match = extractedData.fullText.match(pattern);
        if (match && match[1]) {
          addressToShow = match[1].trim();
          console.log(`Direcci√≥n extra√≠da del texto del recibo: ${addressToShow}`);
          break;
        }
      }
      
      // Si a√∫n no tenemos direcci√≥n, usar la del negocio como √∫ltimo recurso
      if (!addressToShow && businessInfo && businessInfo.address) {
        addressToShow = businessInfo.address;
        console.log(`Usando direcci√≥n del negocio como √∫ltimo recurso: ${addressToShow}`);
      }
    }
    
    const addressText = addressToShow ? `\nUbicaci√≥n: ${addressToShow}` : '';
    
    // Formatear vendedor si est√° disponible
    const vendorText = visionResult.vendor ? 
      `\nAtendido por: ${visionResult.vendor}` : '';
    
    // Enviar mensaje de confirmaci√≥n
    let responseMessage = `¬°Gracias por tu compra en ${businessNameDisplay}! üéâ\n\n`;
    responseMessage += `Monto: S/ ${extractedData.amount}${dateText}${addressText}${vendorText}\n`;
    responseMessage += itemsText;
    
    // Asegurarnos de que el n√∫mero de visitas sea un n√∫mero v√°lido
    const visitsCount = businessData && typeof businessData.visits === 'number' && !isNaN(businessData.visits) 
      ? businessData.visits 
      : 1; // Si no hay datos v√°lidos, asumimos que es la primera visita
    
    responseMessage += `\nHas acumulado ${visitsCount} visitas.`;
    
    // No mostramos el total gastado en el negocio
    
    responseMessage += `\n\nPuedes ver tu tarjeta de fidelidad aqu√≠:\n${cardUrl}`;

    await sendWhatsAppMessage(
      user.phone,
      responseMessage,
      metadata?.phone_number_id
    );

    console.log("‚úÖ Compra registrada y respuesta enviada al usuario");
  } catch (error) {
    console.error("‚ùå Error procesando imagen:", error);
    try {
      await sendWhatsAppMessage(
        user.phone,
        "Lo sentimos, ha ocurrido un error al procesar tu comprobante. Por favor, intenta nuevamente m√°s tarde.",
        metadata?.phone_number_id
      );
    } catch (sendError) {
      console.error("Error enviando mensaje de error:", sendError);
    }
  }
}

// Funci√≥n para procesar mensajes de texto
async function processTextMessage(message, user, whatsappConfig, metadata) {
  try {
    const text = message.text.body.toLowerCase().trim();

    // Comando para consultar puntos
    if (text === "puntos") {
      await sendPointsInfo(user, metadata.phone_number_id);
      return;
    }

    // Comando para ayuda
    if (text === "ayuda" || text === "help") {
      await sendHelpInfo(user, metadata.phone_number_id);
      return;
    }

    // Respuesta gen√©rica para otros mensajes
    await sendWhatsAppMessage(
      user.phone,
      "Para registrar un consumo, env√≠a una foto del comprobante de pago. Para consultar tus puntos, env√≠a la palabra 'puntos'.",
      metadata.phone_number_id
    );
  } catch (error) {
    console.error("‚ùå Error procesando mensaje de texto:", error);
  }
}

// Funci√≥n para enviar informaci√≥n de puntos al usuario
// Funci√≥n para enviar informaci√≥n de puntos al usuario
async function sendPointsInfo(user, phoneNumberId) {
  try {
    // Obtener los puntos del cliente en todos los negocios
    const pointsSnapshot = await db
      .collection("client_points")
      .where("userId", "==", user.id)
      .get();

    if (pointsSnapshot.empty) {
      await sendWhatsAppMessage(
        user.phone,
        "A√∫n no tienes puntos acumulados en ning√∫n negocio. Env√≠a fotos de tus comprobantes de pago para comenzar a acumular puntos.",
        phoneNumberId
      );
      return;
    }

    // Construir mensaje con los puntos en cada negocio
    let message = "üèÜ *Tus puntos acumulados:*\n\n";

    for (const doc of pointsSnapshot.docs) {
      const pointsData = doc.data();
      const businessDoc = await db
        .collection("businesses")
        .doc(pointsData.businessId)
        .get();

      if (businessDoc.exists) {
        const businessData = businessDoc.data();
        message += `*${businessData.name}*: ${pointsData.points} puntos\n`;
      }
    }

    message +=
      "\nPara canjear tus puntos, visita el negocio y muestra este mensaje.";

    await sendWhatsAppMessage(user.phone, message, phoneNumberId);
  } catch (error) {
    console.error("Error enviando informaci√≥n de puntos:", error);
  }
}

// Funci√≥n para enviar informaci√≥n de ayuda al usuario
async function sendHelpInfo(user) {
  const helpMessage = `*¬°Bienvenido a nuestra Tarjeta de Fidelidad Virtual!*

Aqu√≠ tienes algunas instrucciones:

üì∏ *Env√≠a una foto* del comprobante de pago para registrar tu consumo y acumular puntos.

‚úçÔ∏è Env√≠a estos comandos para:
- *puntos*: Consultar tus puntos acumulados
- *ayuda*: Ver este mensaje de ayuda

¬øTienes dudas? Contacta directamente al negocio para m√°s informaci√≥n.`;

  await sendWhatsAppMessage(user.phone, helpMessage);
}

// Exportar la funci√≥n de WhatsApp API usando correctamente la sintaxis de Firebase Functions v2
export const processWhatsAppAPI = onRequest(async (req, res) => {
  // Verificaci√≥n del webhook (GET request)
  if (req.method === 'GET') {
    // Token de verificaci√≥n configurado en la plataforma de WhatsApp
    const VERIFY_TOKEN = whatsappVerifyToken;

    // Par√°metros que env√≠a WhatsApp
    const mode = req.query['hub.mode'];
    const token = req.query['hub.verify_token'];
    const challenge = req.query['hub.challenge'];

    console.log("Verificando webhook con token:", VERIFY_TOKEN);

    // Verificar que el token coincida con nuestro token de verificaci√≥n
    if (mode === 'subscribe' && token === VERIFY_TOKEN) {
      console.log('Webhook verificado correctamente');
      res.status(200).send(challenge);
    } else {
      console.error('Verificaci√≥n fallida. Token incorrecto.');
      res.status(403).send('Verificaci√≥n fallida');
    }
    return; // Importante salir despu√©s de manejar GET
  }

  // Procesar mensajes entrantes (POST request)
  if (req.method === 'POST') {
    try {
      // Responder r√°pidamente para evitar timeouts
      res.status(200).send("EVENT_RECEIVED");

      const body = req.body;
      console.log("üîç Mensaje recibido:", JSON.stringify(body, null, 2));

      // Verificar que sea un mensaje de WhatsApp
      if (!body.object || body.object !== "whatsapp_business_account") {
        console.log("‚ùå Evento no soportado:", body.object);
        return;
      }

      console.log("‚úÖ Objeto WhatsApp v√°lido, procesando entradas...");

      // Procesar cada entrada
      for (const entry of body.entry) {
        console.log("üìù Procesando entrada:", JSON.stringify(entry, null, 2));

        // Procesar cada cambio
        for (const change of entry.changes) {
          console.log("üîÑ Procesando cambio:", change.field);

          if (change.field !== "messages") {
            console.log("‚ö†Ô∏è Campo no soportado:", change.field);
            continue;
          }

          const value = change.value;
          console.log("üìã Valor del cambio:", JSON.stringify(value, null, 2));

          // Guardar la metadata para usar en respuestas
          const metadata = value.metadata || {};

          // Procesar cada mensaje entrante
          if (value.messages && value.messages.length > 0) {
            for (const message of value.messages) {
              const from = message.from;
              console.log(
                `üì± Mensaje recibido de ${from} con ID ${message.id} (tipo: ${message.type})`
              );

              // Buscar o crear usuario
              console.log("üîç Buscando o creando usuario...");
              const user = await findOrCreateUser(from);
              console.log(
                "üë§ Usuario encontrado/creado:",
                JSON.stringify(user, null, 2)
              );

              // Procesar seg√∫n el tipo de mensaje
              if (message.type === "image") {
                console.log("üñºÔ∏è Procesando mensaje de imagen...");
                await processImageMessage(message, user, {}, metadata);
              } else if (message.type === "text") {
                console.log("üìù Procesando mensaje de texto...");
                await processTextMessage(message, user, {}, metadata);
              } else {
                console.log(`‚ö†Ô∏è Tipo de mensaje no soportado: ${message.type}`);
                await sendWhatsAppMessage(
                  from,
                  "Lo siento, solo puedo procesar im√°genes de facturas o comandos de texto. Env√≠a 'ayuda' para m√°s informaci√≥n.",
                  metadata.phone_number_id
                );
              }
            }
          } else {
            console.log("‚ö†Ô∏è No hay mensajes en el cambio");
          }
        }
      }
    } catch (error) {
      console.error("‚ùå Error procesando webhook:", error);
    }
  } else {
    // M√©todo no soportado
    console.log(`M√©todo no permitido: ${req.method}`);
    res.setHeader('Allow', 'GET, POST'); // Informa los m√©todos permitidos
    res.status(405).send('M√©todo no permitido');
  }
});
}
